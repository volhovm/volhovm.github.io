<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-04-15 Sat 13:13 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Linear Relations on QAP Polynomials</title>
<meta name="author" content="Misha Volkhov" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<style> body > div { text-align: justify; max-width: 50em; margin: auto; padding-left: 30px; padding-right: 30px; } </style>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Linear Relations on QAP Polynomials</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgedbd480">1. QAP and R1CS</a></li>
<li><a href="#orgb8787a7">2. QAP Linear Independence Requirement</a></li>
<li><a href="#org02a5daf">3. Relevant Resources</a></li>
<li><a href="#orgea70c30">4. Aligned Linear Independence</a></li>
<li><a href="#org0058238">5. Non-Aligned Linear Independence</a></li>
<li><a href="#org71c936e">6. References</a></li>
</ul>
</div>
</div>
<p>
<i>(this is a copy of the note originally posted <a href="https://priviledge-project.eu/news/linear-relations-on-qap-polynomials-1">here</a> as part of PRIViLEDGE project, part of EU 2020 HORIZON; however that website seems to have died)</i>
</p>

<p>
To use zk-SNARKs in bigger protocols, we must prove their security in an "extended" environment, that is considering all possible interactions of the zk-SNARK primitive with other protocols. Universal Composability (UC, <a href="#org75e3053">[1]​</a>) is a security framework that allows modelling precisely that, and it is a common target for security proofs of protocols, aimed at privacy and zero-knowledge <a href="#orge7a9eb5">[2</a>,<a href="#orge83197e">3</a>,<a href="#orgc2f71af">4</a>,<a href="#orgd75a6a7">5]​</a>. However, one cannot use zk-SNARKs in UC proofs directly &#x2014; this is a known issue stemming from the fact that (standard model) SNARKs are succinct, and thus inherently <i>white-box</i> <a href="#org9a8ed80">[6]​</a>, which intuitively means that security definitions must assume knowledge of the code of the adversary. Such an assumption is stronger than what UC works with, and therefore one must resort to alternative techniques. One option is to use a non-succinct NIZK (e.g. Gro06 <a href="#org45a733d">[7]​</a>), but this comes at the cost of performance, and may even render the protocol impractical. Another way is to apply certain transformations that make a SNARK black-box secure (e.g. C0C0 framework <a href="#org8e1b4e4">[16]​</a>).
</p>

<p>
In our recent work <a href="#orgcc140d0">[8]​</a>, we show two results that help to overcome this problem.
First, we investigate a new security notion, which allows proof randomization (called <i>weak SE</i>), and show that Groth16 SNARK <a href="#orgc3068cb">[9]​</a>, which is nearly-optimal and is commonly used, achieves it.
Second, we show that with the help of this new security notion one can build black-box constructions that realize a (randomizable) UC functionality.
This is often enough for practical applications, and comes at a smaller performance overhead than heavier transformations.
</p>

<p>
In this article, however, we focus on a technical detail that arises in our work, and which was observed before. This detail is a <i>QAP linear and span independence</i> requirement, that is assumed by our security theorems. We believe that this property, although investigated before, was not sufficiently explained, and this article tries therefore to fill this gap.
</p>

<div id="outline-container-orgedbd480" class="outline-2">
<h2 id="orgedbd480"><span class="section-number-2">1.</span> QAP and R1CS</h2>
<div class="outline-text-2" id="text-1">
<p>
We first remind the reader how arithmetic circuits are constructed and what a Quadratic Arithmetic Program is.
</p>

<p>
Consider an arithmetic circuit \(C\) over the prime field \(\mathbb{F}_p = GF(p)\), that is a set of wires and gates computing some value, where the gates are multiplicative and of the following form.
From the set of all \(m\) wires with values \(a_1 \ldots a_m\), the gate outputs \[(k_0 + a_1 k_1 + \ldots + a_m k_m)(c_0 + a_1 c_1 + \ldots + a_m c_m)\]where \(k_i, c_i\) are field elements specific for this gate.
That is, each multiplication gate also includes additive gates to linearly pre-combine the input values.
Let \(n\) be the number of such gates.
Note that since each gate has an output wire (which cannot be used as its input, nor can its dependencies), \(m > n\).
The difference between the two is the number of circuit input wires.
Let us say that these are split into two categories: \(l\) public input wires, and \(l_w\) private input wires (these correspond to the NP instance and witness).
We assume that there is a single output wire of a circuit that is connected to the wire 0 with constant value 1. The following image illustrates the general structure of a circuit; grey labels are "wire values", and blue is used to denote the "internal wires". The upper left triangle is a possible "public input data computation", which is highlighted only to emphasize that not all internal computations involve witness wires.
</p>


<div id="org443ecdf" class="figure">
<p><img src="./qap-2.png" alt="qap-2.png" width="400px" />
</p>
</div>

<p>
Now, a Quadratic Arithmetic Circuit (<a href="#org3c2af17">[15]​</a>, QAP) for this circuit \(C\) consists of the quotient polynomial \(t(X)\) of degree \(n\), and three sets of polynomials \(\{u_i(X), v_i(X), w_i(X)\}_{i=0}^m\) of degree \(n-1\).
The main property of this system is that the assignment \(\{a_i\}\) in \(C\) is valid if and only if \((\sum a_i u_i(X))(\sum a_i v_i(X)) - (\sum a_i w_i(X)) = 0\) modulo \(t(X)\).
</p>

<p>
Another commonly used circuit representation is R1CS (rank-1 constraint system). In this representation, every constraint corresponds to a multiplication gate of the form we described above, and each such constraint is formed by three vectors: \(A = k\) (vector of coefficients that are used to construct the left input of the gate), \(B = c\) (same, w.r.t. the right input), and the output vector \(C\) with the only \(1\) in the position \(i\) (where \(i\) is the gate output wire index), and all other positions \(0\). So, the "evaluation" of the constraint on the wire assignment \(\{a_i\}\) corresponds to \(\langle\{a_i\},A\rangle\cdot\langle\{a_i\},B\rangle = \langle\{a_i\},C\rangle = a_j\)
(angle brackets denote dot product).
We use the notation \((A_j,B_j,C_j)\) to refer to the description of constraint number \(j\).
</p>

<p>
The QAP equation can be thought to evaluate all these constraints simultaneously.
The polynomial \(t(X)\) is defined as a product of \(\prod_{j=1}^n t_j(X) = \prod_{j=1}^n X - r_j\), with \(r_j\) distinct, each corresponding to a multiplication gate (thus degree \(n\)).
If \(\sum a_i u_i(X)\) is viewed as \(\langle \{a_i\}, U(X)\rangle\), with the second element being a vector of \(u_i(X)\), then \(\langle\{a_i\}, U(r_j)\rangle = \langle\{a_i\}, A_j\rangle\).
In other words, QAP polynomials <i>interpolate</i> R1CS constraints, and the QAP equation reduces to each constraint when viewed modulo \(t_j(X)\) (e.g. when we evaluate \(X = r_j\)).
</p>

<p>
Here is how it looks like. On the top we present R1CS constraints evaluated on some (grey) vector of wire values. On the bottom we show a corresponding QAP, which is, when evaluated on \(X = r_j\) (or equivalently viewed modulo \(t_j(X)\)), becomes the second R1CS constraint.
</p>

<div id="orgcd2b7c7" class="figure">
<p><img src="./qap-4.png" alt="qap-4.png" width="600px" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgb8787a7" class="outline-2">
<h2 id="orgb8787a7"><span class="section-number-2">2.</span> QAP Linear Independence Requirement</h2>
<div class="outline-text-2" id="text-2">
<p>
In our weak SE proof of Groth16 (and also in the proof of our second black-box construction), we use
the assumption that \({u_0(X) \ldots u_l(X)}\) are linearly independent (LID), and
that furthermore the span of this set does not intersect with the span of
\({u_{l+1}(X)\ldots u_m(X)}\), that is the two sets are mutually linearly independent.
This assumption was introduced previously, and it also appears, for instance,
in Groth-Maller17 <a href="#org8f5b123">[10]​</a>, and <a href="#orgd1616da">[11]​</a>.
But what is the intuition behind this property, and why is it reasonable to
assume it?
</p>

<p>
First, recall that by linear independence of \(\{u_i(X)\}_{\mathcal{I}}\) for some \(\mathcal{I}\) we have that \(\forall k_0 \ldots k_l \in \mathbb{F}_p \ldotp\) \(\sum_{\mathcal{I}} k_i u_i(X) = 0\) implies \(k_i = 0\) for all \(i \in \mathcal{I}\). We interpret polynomials as vectors in \(\mathbb{F}_p^n\) (since the degree of \(u_i(X)\) is \(n-1\)). Immediately we notice that it is not possible for the whole set \(u_0(X) \ldots u_m(X)\) (similarly for \(v_i(X)\) and \(w_i(X)\)) to be linearly independent. The polynomials are of degree \(n-1\), and there are \(m+1\) of them, where \(n\) is the number of gates and \(m\) is the number of wires. Since each gate has exactly one output wire, \(m = n + l + l_w\), where \(l\) is the number of public inputs, and \(l_w\) is the number of private witness inputs. Therefore, the maximal possible rank of the matrix with \(u_i(X)\) concatenated (as either rows or columns) is \(n\), and thus full linear independence is impossible. This also means that by requiring \(\{u_0(X) \ldots u_l(X)\}\) LID, we imply \(\{u_{l+1}(X) \ldots u_m(X)\}\) LD (linearly dependent).
</p>
</div>
</div>
<div id="outline-container-org02a5daf" class="outline-2">
<h2 id="org02a5daf"><span class="section-number-2">3.</span> Relevant Resources</h2>
<div class="outline-text-2" id="text-3">
<p>
Most of the public resources on the issue lead in one way or another to the following discussion of a bug in the zk-SNARK by Ben-Sasson et al. <a href="#orgd1616da">[11]​</a>.
The following list attempts to summarize the public information covering the issue of QAP linear independence.
</p>
<ul class="org-ul">
<li>The zk-SNARK presented in <a href="#orgd1616da">[11]​</a> is built on Pinocchio, and its Lemma 2.4, claiming the existence of QAP for circuits, also says that the constructed QAP satisfies a "non-degeneracy" condition. The original version of the paper by this means that \(\{u_i(X)\}_{i=0}^l\) are non-zero and distinct.</li>
<li>The note by Brian Parno <a href="#org84936fb">[12]​</a> describes a bug that does not appear in Pinocchio, but is present in the original technical (full) version of <a href="#orgd1616da">[11]​</a>, precisely in this non-degeneracy condition. The bug does not merely add instance-malleability to the proofs, but breaks soundness of the NIZK. The new, revised version of <a href="#orgd1616da">[11]​</a>, now states (in the same Lemma 2.4) that \(u_i(X)\) are linearly independent for the first \(l\) (input) wires. Furthermore, the new version suggests how to satisfy this requirement: adding \(1+l\) constraints is enough to achieve the non-linearity condition: \(1 \cdot 0 = 0\) and \(a_i \cdot 0 = 0\) for \(i \in [1,l]\).</li>
<li>The <a href="https://leastauthority.com/blog/a-bug-in-libsnark/">blog post</a> by Least Authority called "A Bug in libsnark" describes this very same bug, but with respect to the particular implementation in <code>libsnark</code>, in the module that converts R1CS to QAP. More details on the bug are provided, essentially describing the same technique of adding \(n+1\) linear constraints as in the new version of <a href="#orgd1616da">[11]​</a>.</li>
<li>The <a href="http://coders-errand.com/how-to-build-a-quadratic-arithmetic-program/">blog post</a> by Alex Pinto, "How to Build a Quadratic Arithmetic Program", following <a href="#orgd1616da">[11]​</a>, mentions that the non-degeneracy condition constraints must be introduced for conversion from R1CS to QAP, that lead to QAP linear independence, without giving a detailed explanation.</li>
<li>Ariel Gabizon in the eprint note <a href="#org2d3fd5e">[13]​</a> identifies another issue with <a href="#orgd1616da">[11]​</a>. The proposed way to fix it (Section 3) also includes the linear disjointness condition (span independence), as in our work. They notice that this condition is also satisfied in QAP of <code>libsnark</code>, and also that it appears in a relevant MPC protocol for SNARK public parameters generation <a href="#orgcdddae4">[14]​</a>.
The updated version of <a href="#orgd1616da">[11]​</a> now contains this condition too, and the Remark 2.5 now also includes a comment on it.</li>
</ul>


<p>
Other than that, there is little or no information on the LID requirement, and even the presented articles do not explain how exactly does the transformation of <a href="#orgd1616da">[11]​</a> work.
This note attempts to provide some explanation and description of the mentioned linear and span independence properties.
</p>
</div>
</div>
<div id="outline-container-orgea70c30" class="outline-2">
<h2 id="orgea70c30"><span class="section-number-2">4.</span> Aligned Linear Independence</h2>
<div class="outline-text-2" id="text-4">
<p>
It is tempting to intuitively connect the linear independence condition of \(u_i(X)\) with some circuit property.
Although it is harder to find a good intuition for standard LID, we explain one such possible interpretation for the <i>weaker</i> case of <i>aligned LID</i> first, which we introduce exactly with this purpose.
We say that a QAP has <b>aligned linear dependence</b> if
\({(u_{i,0} \ldots u_{i,n-1}, v_{i,0} \ldots v_{i,n-1}, w_{i,0}, \ldots w_{i,n-1})}\) are linearly dependent for some subset of indices \({0\ldots m}\).
That is, we consider 3n-vectors \((u_i(X), v_i(X), w_i(X))\) instead of viewing
each \(p_i(X)\) (with \(p ∈ {u,v,w}\)) separately.
</p>

<p>
Assume aligned LD of two vectors first:
\((u_1(X),v_1(X),w_1(X)) = k \cdot (u_2(X),v_2(X),w_2(X))\).
It is easy to see that if \({a_0 \ldots a_m}\) is a QAP-satisfying wire assignment,
then for all \(e \in \mathbb{F}_p\):
\[a_1 p_1(X) + a_2 p_2(X) = e p_1(X) + (a_2 + k (a_1 - e)) p_2(X)\]
for \(p ∈ {u,v,w}\).
Because of perfect soundness of the QAP, this alternative assignment \(\{a_i'\}\),
where \(a_1' = e, a_2' = (a_2 + k (a_1 - e))\), and all other \(a_i' = a_i\), must
also satisfy the relation.
In the circuit, this ad-hoc replacement of two wires in the assignment is possible
in several cases.
It could be that the wires are free, not used in any gates at all, then
<i>any</i> assignment on them satisfies the circuit, and in particular both \(\{a_i\}\)
and \(\{a_i'\}\).
Or it could also be that \(a_1\) is an input wire, \(a_2\) is an output wire, and
between them there is some multi-gate computation \(a_2 = f(a_1, a_3 \ldots a_m)\)
with \(f\) linear in \(a_1\).
</p>

<p>
The example generalizes to aligned linear dependence of many vectors.
That is, if a subset of \(n\) 3-vectors is linearly dependent, then we can set any
\(n-1\) wires from the corresponding set to arbitrary values \(\{e_i\}\), and the last
value will be defined as a linear combination of these \(\{e_i\}\).
It could be that these \(n\) wires are not connected to anything at all, or that
they form a bamboo (non-branching tree) of trivial multiplication gates:
each successive gate output is a linear function of the previous wire.
</p>

<p>
These few examples should give <i>some</i> intuition about what circuits can have aligned LID, but they do not constitute a complete characterization.
</p>
</div>
</div>
<div id="outline-container-org0058238" class="outline-2">
<h2 id="org0058238"><span class="section-number-2">5.</span> Non-Aligned Linear Independence</h2>
<div class="outline-text-2" id="text-5">
<p>
The <b>non-aligned</b> linear independence of \(\{u_i(X)\}\) is a stronger requirement than the aligned variant we just overviewed: whenever \(\{u_i(X)\}\) are LID, the whole QAP is aligned LID.
(This is easy to see, as when we have aligned LD with coefficients \(\{k_i\}\) for some set of indices \(\mathcal{I}\), the same set of coefficients forms linearly dependent combinations for each \(u_i(X),v_i(X),w_i(X)\)).
In the previous case of aligned LID we merely used QAP correctness (that is, the QAP equation) to deduce the intuition of linear dependency of wires.
Now, to analyse non-aligned linear independence of each \({p_i(X)}\) separately, we will check if this desired linear independence condition can be satisfied by construction <a href="#org3c2af17">[15]​</a>.
We remind that what we need to achieve for our theorem to go through is: \(\{u_i(X)\}_{0}^l\) LID, and \(\text{Span}(\{u_i(X)\}_0^l) \cap \text{Span}(\{u_i(X)\}_{l+1}^m) = \emptyset\).
</p>


<p>
Observe that each \(u_i(X)\) modulo \(t_j(X)\) is
a coefficient \(A_{j,i}\) that specifies by which the corresponding left input
a wire number \(i\) should be linearly scaled before performing gate number \(j\) multiplication.
So for a fixed wire number \(i\), \(u_i(X)\) modulo all \(t_j(X)\) gives us the set of all these
\({A_{j,i}}\) &#x2014; all left scalars this wire \(i\) participates in as a left input.
If \(u_1(X) \ldots u_l(X)\) are linearly dependent (\(\sum_{i=1}^l k_i u_i(X) = 0\)), then
reviewing this sum modulo \(t_j(X)\) for each \(j\) gives us \(\sum k_i A_{j,i} = 0\)
(note that \(k_i ∈ \mathbb{F}_p\) does not reduce modulo \(t_j(X) = X - r_j\)).
Therefore, if \(u_i(X)\) are LD, then all these equations are satisfied over
all \(t_j(X)\): for each gate \(j\), for each corresponding \(A_{j}\), the set of \(k_i\) satisfies the dot product w.r.t. \(A_{j,i}\).
On the contrary, what linear <i>independence</i> would imply, is that for any \({k_i}\) there is at least one gate that
this combination does not work with.
We can achieve LID for a subset of wires by performing a simple circuit transformation, as suggested in <a href="#orgd1616da">[11]​</a>.
</p>

<p>
To make the \(u_1(X)\ldots u_l(X)\) linearly independent, we create \(l\) extra gates
(let their indices be \(0\) to \(l\) too, so we prepend them to the beginning of the list), where each gate number \(j\) uses exactly
one input wire number \(i\) as a left input, and value 0 as a right input.
So, for \(j \in [0,l]\) we set \(A_{j,j} = 1\), and all other \(A_{j,i} = 0\), as well as \(B_{j,i} = C_{j,i} = 0\) except for \(C_{j,l+l_w+j} = 1\) (if we assume \(l+l_w+j\) is an index of output wire of gate number \(j\)).
Similarly, for \(u_0(X)\) we create a single gate (number \(0\)) that takes the constant wire number \(0\) (carrying constant value \(1\)) with coefficient \(1\), for the left input, and sets right input to \(0\). On the following illustration the additional gates are drawn in green; note that they lack right input, but still have an output wire.
</p>


<div id="org4134e50" class="figure">
<p><img src="./qap-3.png" alt="qap-3.png" width="400px" />
</p>
</div>

<p>
Now, the sum modulo each \(t_j(X)\) for \(j \in [0,l]\) reduces to \(k_j A_{j,j} = 0\).
Since \(A_{j,j} = 1\), \(k_j = 0\), and since we do it for each \(j\), <i>each</i> coefficient of the linear combination is zero, and thus it is trivial.
So the first linear independence condition is satisfied.
</p>

<p>
Regarding the second condition, span independence of \(u_0(X) \ldots u_l(X)\) and
\(u_{l+1}(X)\ldots u_m(X)\), assume by contradiction that \(f(X) = \sum_0^l k_{1,i} u_i(X) = \sum_{l+1}^m k_{2,i} u_i(X)\) and \(f(X) \neq 0\).
When viewed modulo \(t_j(X)\) for \(j \in [0,l]\) (our extra gates), the left hand side becomes \(\sum_0^l k_{1,i} A_{j,i} = k_{1,j} A_{j,j}\).
The right side is, similarly, \(\sum_{l+1}^m k_{2,i} A_{j,i}\). But since wires \([l+1,m]\) are not used as <i>left inputs</i> for the gates \([0\ldots l]\) (these gates receive inputs strictly from wires \([0\ldots l]\)), we must have \(A_{j,i} = 0\) for \(i ∈ [l+1,m]\).
Therefore, any \(\sum_{l+1}^m k_{2,i} u_i(X)\) is zero modulo \(t_j(X)\) for \(j ∈ [0,l]\), and thus, as before we are only left with LHS
\(k_{2,j} A_{j,j} = 0\) which implies \(k_{2,j} = 0\), for each such \(j\).
So \(f(X) = 0\), a contradiction, which proves span independence.
</p>

<p>
<i>This shows why the transformation of <a href="#orgd1616da">[11]​</a> is enough to satisfy both conditions necessary for the theorems in our work <a href="#orgcc140d0">[8]​</a>.</i>
</p>

<p>
The last thing we would like to note is that if we apply the transformation to <i>both public and private witness wires</i>, we obtain aligned LID of <i>all</i> QAP wires.
</p>

<p>
First we claim that the set \(\{w_0(X), w_{l+l_w+1}(X)\ldots w_m(X)\}\), corresponding to the multiplication-gate output wires (call these indices \(\mathcal{I}_o\)), is linearly independent. Observe that \(w_i(X) = 1 \text{ mod } t_j(X)\) where \(i\) is the output wire of gate \(j\), and it is \(0\) modulo \(t_\iota(X)\) for all other \(\iota\) &#x2014; hence if the set is linearly dependent, with coefficients \(\{k_i\}\) then \(\sum_{\mathcal{I}_0} k_i w_i(X)\) modulo \(X - r_j\) implies \(k_i \cdot 1 = 0\). Therefore, in every linear combination \(\{k_i\}\) such that \(\sum k_i w_i(X) = 0\), each coefficient is zero, and this set is linearly independent. Since the set is of size \(n\) and each \(w_i(X)\) in it is a n-vector, the corresponding matrix of \(w_i(X)\) concatenated is full rank.
</p>

<p>
Regarding the input wires set \(\{w_i(X)\}_{i=1}^{l+l_w}\), each element of it is set to be \(0\) modulo each \(t_i(X)\), and thus modulo \(t(X) = \prod t_i(X)\) (by CRT). Since \(w_i(X)\) maximum degree is \(n-1\), being zero modulo \(t(X)\) means being constant zero, so these prefix \(w_i(X)\) (for input wires) are (trivially) linearly dependent.
</p>

<p>
Now, this means that if we have a nontrivial aligned linear combination, it must include at least one coefficient from the set of input wires \(\mathcal{I}_i := [1,l+l_w]\) (public or private).
Otherwise, when the combination of 3-vectors is limited only to gate outputs (\(\mathcal{I}_o = [0,l+l_w+1,\ldots,m]\)), the combination should also hold when viewed over \(\{w_i(X)\}\), but we have already deduced this is impossible because these polynomials are LID.
But by the previous argument, as long as \(\sum k_i u_i(X)\) includes some indices \(i \in \mathcal{I}_i\) (assuming both public and private inputs transformed as explained before), all such \(k_i = 0\) &#x2014; this is, again, due to the fact that only \(\mathcal{I}_i\) wires participate in our "extra" gates as left inputs, and they do it once per each such gate.
So we are again in the case of linear combination limited to \(\mathcal{I}_o\), where we have already proven LID for \(\{w_i(X)\}\).
Thus, we arrive at a contradiction, and the whole QAP is aligned LID.
</p>
</div>
</div>
<div id="outline-container-org71c936e" class="outline-2">
<h2 id="org71c936e"><span class="section-number-2">6.</span> References</h2>
<div class="outline-text-2" id="text-6">
<ol class="org-ol">
<li><a id="org75e3053"></a> Canetti, Ran. <i>"Universally composable security: A new paradigm for cryptographic protocols."</i> In Proceedings 42nd IEEE Symposium on Foundations of Computer Science, pp. 136-145. IEEE, 2001.</li>
<li><a id="orge7a9eb5"></a> Kosba, Ahmed, Andrew Miller, Elaine Shi, Zikai Wen, and Charalampos Papamanthou. <i>"Hawk: The blockchain model of cryptography and privacy-preserving smart contracts."</i> In 2016 IEEE symposium on security and privacy (SP), pp. 839-858. IEEE, 2016.</li>
<li><a id="orge83197e"></a> Kerber, Thomas, Aggelos Kiayias, and Markulf Kohlweiss. <i>"Kachina-Foundations of Private Smart Contracts."</i> IACR Cryptol. ePrint Arch. 2020 (2020): 543.</li>
<li><a id="orgc2f71af"></a> Kerber, Thomas, Aggelos Kiayias, and Markulf Kohlweiss. <i>"Mining for Privacy: How to Bootstrap a Snarky Blockchain."</i> IACR Cryptol. ePrint Arch. 2020 (2020): 401.</li>
<li><a id="orgd75a6a7"></a> Kerber, Thomas, Aggelos Kiayias, Markulf Kohlweiss, and Vassilis Zikas. <i>"Ouroboros crypsinous: Privacy-preserving proof-of-stake."</i> In 2019 IEEE Symposium on Security and Privacy (SP), pp. 157-174. IEEE, 2019.</li>
<li><a id="org9a8ed80"></a> Gentry, Craig, and Daniel Wichs. <i>"Separating succinct non-interactive arguments from all falsifiable assumptions."</i> In Proceedings of the forty-third annual ACM symposium on Theory of computing, pp. 99-108. 2011.</li>
<li><a id="org45a733d"></a> Groth, Jens. <i>"Simulation-sound NIZK proofs for a practical language and constant size group signatures."</i> In International Conference on the Theory and Application of Cryptology and Information Security, pp. 444-459. Springer, Berlin, Heidelberg, 2006.</li>
<li><a id="orgcc140d0"></a> Baghery, Karim, Markulf Kohlweiss, Janno Siim, and Mikhail Volkhov. <i>"Another look at extraction and randomization of Groth’s zk-SNARK."</i> FC 2021 (2021).</li>
<li><a id="orgc3068cb"></a> Groth, Jens. <i>"On the size of pairing-based non-interactive arguments."</i> In Annual international conference on the theory and applications of cryptographic techniques, pp. 305-326. Springer, Berlin, Heidelberg, 2016.</li>
<li><a id="org8f5b123"></a> Groth, Jens, and Mary Maller. <i>"Snarky Signatures: Minimal Signatures of Knowledge from Simulation-Extractable SNARKs."</i> In Annual International Cryptology Conference, pp. 581-612. Springer, Cham, 2017.</li>
<li><a id="orgd1616da"></a> Ben-Sasson, Eli, Alessandro Chiesa, Eran Tromer, and Madars Virza. <i>"Succinct non-interactive zero knowledge for a von Neumann architecture."</i> In 23rd {USENIX} Security Symposium ({USENIX} Security 14), pp. 781-796. 2014.</li>
<li><a id="org84936fb"></a> Parno, Bryan. <i>"A Note on the Unsoundness of vnTinyRAM's SNARK."</i> IACR Cryptol. ePrint Arch. 2015 (2015): 437.</li>
<li><a id="org2d3fd5e"></a> Gabizon, Ariel. <i>"On the security of the BCTV Pinocchio zk-SNARK variant."</i> IACR Cryptol. ePrint Arch. 2019 (2019): 119.</li>
<li><a id="orgcdddae4"></a> Bowe, Sean, Ariel Gabizon, and Matthew D. Green. <i>"A multi-party protocol for constructing the public parameters of the Pinocchio zk-SNARK."</i> In International Conference on Financial Cryptography and Data Security, pp. 64-77. Springer, Berlin, Heidelberg, 2018.</li>
<li><a id="org3c2af17"></a> Gennaro, Rosario, Craig Gentry, Bryan Parno, and Mariana Raykova. <i>"Quadratic span programs and succinct NIZKs without PCPs."</i> In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pp. 626-645. Springer, Berlin, Heidelberg, 2013.</li>
<li><a id="org8e1b4e4"></a> Kosba, Ahmed, Zhichao Zhao, Andrew Miller, Yi Qian, H. Chan, Charalampos PAPAMAN-THOU, Rafael Pass, SHELAT ABHI, and EC SHI. <i>"C∅ C∅: A framework for building composable zero-knowledge proofs."</i> Cryptology ePrint Archive, Report 2015/1093 (2015).</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-03-16</p>
<p class="author">Author: Misha Volkhov</p>
<p class="date">Created: 2023-04-15 Sat 13:13</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
