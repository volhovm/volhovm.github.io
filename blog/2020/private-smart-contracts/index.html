<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Reasoning About Privacy in Smart Contracts | Misha Volkhov</title> <meta name="author" content="Misha Volkhov"> <meta name="description" content="Misha Volkhov's personal website. "> <meta name="keywords" content="volhovm, zero-knowledge, portfolio, cv, jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://volhovm.github.io/blog/2020/private-smart-contracts/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bolder">Misha </span>Volkhov</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Reasoning About Privacy in Smart Contracts</h1> <p class="post-meta">February 10, 2020</p> <p class="post-tags"> </p> </header> <article class="post-content"> <div id="markdown-content"> <style type="text/css">p{text-align:justify}figure{text-align:center;margin-left:auto;margin-right:auto}.img-fluid{max-width:85%}</style> <p><small> <em>(originally posted <a href="https://priviledge-project.eu/" rel="external nofollow noopener" target="_blank">here</a> as part of the PRIViLEDGE project, EU 2020 HORIZON; however that website seems to have died)</em> </small></p> <p>Smart contracts have become a standard way to implement complex online interaction patterns involving the exchange of both cryptographic currency and data on blockchain in a unified and generalised manner. This approach was popularised by Ethereum, and examples include ERC20 token contracts, decentralised exchange contracts (Idex, EtherDelta), and even contract-based games, like CryptoKitties. Smart contracts allow both developers and regular users to express complex behavioural requirements and patterns using a high-level programming language. At the same time, the public nature of most popular smart contract systems restricts the expressivity of contracts. Public fields of the contract are visible to everyone, and transactions reveal a lot of private data – which address triggered the contract change, and what this execution was like. Many privacy-preserving communication patterns that need this information to be private and accessible to only specific parties run into resource or design complexity limits, even though it is theoretically possible to implement them. Moreover, the security proofs for these types of systems are cumbersome because of additional non-standard and non-unified layers of abstractions introduced by implementing the privacy-preserving logic on top of the public smart contract functionality instead of designing smart contracts environments with privacy support in mind.</p> <p>In this blog post we will look at the two proposals for private smart contract systems, namely Zkay [<a href="#ref1">1</a>] and Kachina [<a href="#ref2">2</a>], both of which provide a way to express different privacy properties in smart contracts, and to reason about them. While Zkay serves as an illustrative example of a practical smart contract framework, showing the end user’s or programmer’s perspective, Kachina offers a more theoretical take on what privacy is, allowing for detailed security analysis of the functionalities involved in the smart contract.</p> <p>Zkay system consists of the language, more precisely an extension of the Solidity language used in Ethereum, and a compiler that transforms the smart contract code into two independent pieces of code – the Solidity contract that can be run, for example, on the Ethereum blockchain, and a circuit description of the code that is supposed to be run inside a zk-SNARK. The zkay language is different from its base Solidity language in having fine-grained privacy annotations that specify the ownership of the internal contract variables – if <code class="language-plaintext highlighter-rouge">T</code> is a type of variable, then <code class="language-plaintext highlighter-rouge">T@A</code> is a T data structure that belongs to the address A. These privacy annotations allow limiting the access of the concrete script variable to the concrete single user’s address, so that the variable can only be read by the owner of that address. Another important language feature is careful handling of statements that reclassify the secret information – whenever one wants to publish a secret value, or give it away to another party, a call to the <code class="language-plaintext highlighter-rouge">reveal</code> function allows it to do that. In this way, semantics of the language separates private computations from the public ones, and forces the contract author to explicitly declare this boundary.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/2020-02-10-private-smart-contracts/image2-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/2020-02-10-private-smart-contracts/image2-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/2020-02-10-private-smart-contracts/image2-1400.webp"></source> <img src="/assets/img/2020-02-10-private-smart-contracts/image2.png" style="max-width: 60%;" class="img-fluid rounded" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>The main example in the paper, presented on Figure 1, presents a smart contract <code class="language-plaintext highlighter-rouge">MedStats</code> that emulates a simplistic medical database. This contract stores a variable mapping each user to a boolean value that indicates whether this user is in a risk group or not (called <code class="language-plaintext highlighter-rouge">risk</code>), and a global private counter of all the users in the risk group. The entity <code class="language-plaintext highlighter-rouge">hospital</code> can then assign these values and increase a private counter (that is not visible to anyone else), and users can read their own risk assignment from their own private element of the mapping <code class="language-plaintext highlighter-rouge">risk</code> (and again, nobody else can read from it). The smart contract guarantees that the counter is consistent with the risk information given to users.</p> <p>In this example, we clearly see that privacy is ensured in a way that is understandable for programmers – adding an additional language feature which induces extra privacy semantics. This kind of semantics could be (and is) achieved within more powerful languages by using strict types; one good analogy is private/public object fields, or state and reader monads in functional languages. These language features restrict the behaviour that we want to avoid, namely revealing secret information to other parties, by performing type-checking. Under the hood, ZKay extracts the private parts of the contract into arithmetic circuits, that update the encrypted values, corresponding to the private variables. And the correctness of transition from one private state (with one set of variables) into another is guaranteed by the zk-SNARK which is parameterized by this extracted circuit. Now how privacy is achieved makes perfect sense – we update certain encrypted values in zero-knowledge, but does it allow us to express all the private contracts we would like to work with? Is there a simple way to concisely present the exact places we might leak information from? For instance, if we update a certain encrypted value, the very fact it was updated is publicly visible (because the ciphertext changes whenever the underlying plaintext changes), so this absence of unlinkability seemingly prevents us from implementing zcash-like transactions using just the tools provided.</p> <p>Kachina [<a href="#ref2">2</a>] approaches these issues from the opposite direction. Instead of defining a programming language extension it provides a most general abstraction for public and private state separation, together with a framework in which contracts can be proven secure. At the base of Kachina lies the Universal Composability (UC) framework [<a href="#ref3">3</a>] – a set of formal specification and proof techniques that allow proving cryptographic protocols secure. Kachina builds on UC, and suggests the following contract design flow.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/2020-02-10-private-smart-contracts/image1-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/2020-02-10-private-smart-contracts/image1-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/2020-02-10-private-smart-contracts/image1-1400.webp"></source> <img src="/assets/img/2020-02-10-private-smart-contracts/image1.png" style="max-width: 60%;" class="img-fluid rounded" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>First, we need to formally specify, in the UC pseudocode language, the contract transition function \(\Gamma(w)\) – the core of the interaction of users and the contract. This function, although may look quite similar to any other contract one may come across, has a distinctive restriction – it must be written in such a way that interactions with the public state of the contract and a set of private states (one per user) are abstracted as communication with separate programs, called public or private state oracles respectively. This forces us to separate publicly accessible information, such as public contract variables, from the private states of users, which are generally stored on the user side, and may include secret keys, nonces, etc – whatever is needed to act as a contract party. Moreover, the transition function itself doesn’t maintain any state, since it is all delegated to the oracles. This state-oracles approach itself may sound reasonably familiar to programmers, as it is ubiquitous in software engineering (imagine oracles being internal objects of the functionality object, with call access to them only), but the difficult problems solved by Kachina lie more in the precise definitions and abstractions that allow us to later reason about this transition function. Figure 2 show the transition function \(\Gamma\) transforming smart contract input \(w\) (which can be thought of as a query, or RPC with the arguments), to the output y, while communicating with a public oracle at the right side, transforming public state \(\sigma\) to new \(\sigma'\), and correspondingly a set of private oracles each changing private state \(\rho\) to \(\rho'\).</p> <p>The transition function is itself a minimal piece of logic that describes the behaviour of the contract. It answers the main question “given a certain request to the contract, how will our public and private states change?”. But to proceed with the proof and to reason about system security guarantees, we will define two more objects – an ideal behaviour function \(\Delta\) and a leakage function \(\Lambda\). The first one expresses a high-level intuition about the behaviour of \(\Gamma\) – as if there were no concrete cryptographic objects in the contract, and it was allowed only to emulate the behaviour of the contract, allowing for adversarial input. The leakage function maps every possible input to the contract to the leakage that this contract does provide. After defining these two objects that precisely specify our expectation about functionality that we provide, possible adversarial interference, and a leakage, we can proceed with the security proof in the UC manner. Kachina then guarantees the soundness of the system – that is, it won’t be possible to prove the system secure if our leakage expectations \(\Lambda\) are strictly weaker that the real leakage, or if our modeled behaviour and possible attacks in \(\Delta\) are less general than ones allowed by the transition function defined earlier. In other words, security is guaranteed by reducing the functional and leakage related claims to a small readable piece of pseudocode (that we can agree or disagree with), and then proving the real contract correspondence to it.</p> <p>The real contract that can be put on the blockchain modifies our contract transition function \(\Gamma\), transforming our abstract communication-with-oracles pattern into zero-knowledge proofs of the fact this communication (together with its private parts) corresponds to the contracts’ code. Many more parts of Kachina help us to understand and write the contract, for instance it provides a way to formalise public and private state consistency, allow for proper transaction reordering, and so on.</p> <p>Thus, Kachina serves as a general framework, in which the security properties can be concisely expressed, and the correspondence of the concrete smart contract system can be proven secure with respect to these properties. Being a theoretical work, Kachina does not provide a language or a compiler, but relies itself on the UC language. At the same time, its expressive power is quite high – it easily captures zcash-like private payments (which is the main example in the paper’s body), and the zkay privacy abstraction, with its encrypted value transitions, can also be quite straightforwardly expressed in Kachina, putting encrypted values into the public state, while having secret keys in the private ones.</p> <p>Our research focuses on bringing these ideas together – is it possible to extend Zkay language annotations even further? What would be the best smart contract language to provide a seamless integration with state-oracle abstraction – either by using the interface to define them directly, or transforming other approaches, as, for example, privacy types access, into the code that will fit the state oracle abstraction criteria? Parts of these questions are to be resolved by the ZK toolkit, which is currently under research and development.</p> <h2 id="references">References</h2> <p><a name="#ref1">[1]</a> Steffen, Samuel, et al. <em>“zkay: Specifying and enforcing data privacy in smart contracts.”</em> Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security. 2019.</p> <p><a name="#ref1">[2]</a> Kerber, Thomas, Aggelos Kiayias, and Markulf Kohlweiss. <em>“Kachina–Foundations of Private Smart Contracts.”</em> https://drwx.org/papers/kachina.pdf</p> <p><a name="#ref1">[3]</a> Canetti, Ran. <em>“Universally composable security: A new paradigm for cryptographic protocols.”</em> Proceedings 42nd IEEE Symposium on Foundations of Computer Science. IEEE, 2001.</p> </div> </article><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"alshedivat/al-folio","data-repo-id":"MDEwOlJlcG9zaXRvcnk2MDAyNDM2NQ==","data-category":"Comments","data-category-id":"DIC_kwDOA5PmLc4CTBt6","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,a])=>giscusScript.setAttribute(t,a)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="sticky-bottom mt-5"> <div class="container"> © Copyright 2024 Misha Volkhov. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. <a href="https://github.com/volhovm/volhovm.github.io" rel="external nofollow noopener" target="_blank">Source</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/copy_code.js" type="text/javascript"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>